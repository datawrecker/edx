<ol style="max-height: 451px;" id="transcript-captions" class="subtitles" tabindex="0" role="group" aria-label="Activating an item in this group will spool the video to the corresponding time point. To skip transcript, go to previous item."><li tabindex="-1" style="height: 205.5px;" class="spacing"></li><li tabindex="0" data-start="1400" data-index="0">Hello and welcome to video 4.4 on PID-Control.</li><li tabindex="0" data-start="5300" data-index="1">In the previous video we have seen how we can model the rigid body kinematics of a rigid body.</li><li tabindex="0" data-start="11900" data-index="2">And we will use that again now for bringing on our example from P-Control before.</li><li tabindex="0" data-start="19869" data-index="3">So consider just a simple rigid body like the soccer ball here that is free floating</li><li tabindex="0" data-start="25849" data-index="4">in 1 dimensional space, without any gravity.</li><li tabindex="0" data-start="28789" data-index="5">This means that the body itself is located at a certain location x and it's moving</li><li tabindex="0" data-start="35030" data-index="6">in a certain direction x dot.</li><li tabindex="0" data-start="38239" data-index="7">And so we can specify a really simple system model, where we just say: the current position</li><li tabindex="0" data-start="44719" data-index="8">depends on the previous position plus the current speed. With that we assume that our</li><li tabindex="0" data-start="50399" data-index="9">time constant delta t equals 1.</li><li tabindex="0" data-start="53850" data-index="10">And now assume that you are starting at the origin. So our current position is 0, and</li><li tabindex="0" data-start="58800" data-index="11">also our current speed is 0.</li><li tabindex="0" data-start="62339" data-index="12">And then, if we look at the time evolution of such a system we can see that nothing</li><li tabindex="0" data-start="68650" data-index="13">changes because in every new time step we just add 0 + 0.</li><li tabindex="0" data-start="73190" data-index="14">And that means that our object, will stay exactly at the same point.</li><li tabindex="0" data-start="80600" data-index="15">Now imagine further that we can now apply at every time instant a certain force F_t.</li><li tabindex="0" data-start="88200" data-index="16">And just for simplicity we assume that this force is our control, u, maybe scaled by some factor.</li><li tabindex="0" data-start="97900" data-index="17">As we now, this force that we apply leads</li><li tabindex="0" data-start="104200" data-index="18">to an acceleration, x double dot, and imagine now that we want to find controls so that</li><li tabindex="0" data-start="112960" data-index="19">the rigid body moves to a desired location of 1.</li><li tabindex="0" data-start="118280" data-index="20">And now, as we already know, we could just apply P-control to that, which means that</li><li tabindex="0" data-start="123490" data-index="21">the desired location x_des minus our current location x_(t-1) from the last time step.</li><li tabindex="0" data-start="133200" data-index="22">And then, we multiply that by a certain control gain K to obtain our control signal.</li><li tabindex="0" data-start="140760" data-index="23">Now what will happen if we apply this to a rigid body?</li><li tabindex="0" data-start="144600" data-index="24">And then, the result looks as follows: we start again now at the origin of our object,</li><li tabindex="0" data-start="153100" data-index="25">and we want to go to a location of 1. So our P-controller will generate a large control,</li><li tabindex="0" data-start="161239" data-index="26">in this case of 0.15, because we have set K to 0.15, which will make the object accelerate</li><li tabindex="0" data-start="170920" data-index="27">towards its desired location and then roughly at 4 seconds time we will hit the desired</li><li tabindex="0" data-start="178219" data-index="28">location. But because we still have some inertia the object will continue beyond this point and actually</li><li tabindex="0" data-start="184500" data-index="29">overshoot massively up to a position of 2. And then, during this time already our controller</li><li tabindex="0" data-start="192730" data-index="30">will generate a negative control output to decelerate the object</li><li tabindex="0" data-start="197590" data-index="31">and you can see that this leads to a very bad oscillation. And actually does not make</li><li tabindex="0" data-start="203090" data-index="32">our object come closer to the desired location.</li><li tabindex="0" data-start="207700" data-index="33">So this is not good, P-controls for rigid bodies that are not damped are not sufficient.</li><li tabindex="0" data-start="216870" data-index="34">The idea is now to use a so called derivative term, so we have a so called PD-controller then,</li><li tabindex="0" data-start="227180" data-index="35">where the first part is exactly the same and the second part at the same time tries to</li><li tabindex="0" data-start="232510" data-index="36">minimize the distance between the desired speed that we try to achieve and our current speed.</li><li tabindex="0" data-start="240989" data-index="37">And this now means that at this location of 1 we desired to have a speed of 0 so our x dot desired</li><li tabindex="0" data-start="250340" data-index="38">equals 0 to make sure that at the end, when we reach this goal, we want to have 0 velocity.</li><li tabindex="0" data-start="257298" data-index="39">And then, this leads to the following behavior: you can see now in the bottom plot we still</li><li tabindex="0" data-start="265860" data-index="40">have a proportional part that will accelerate our body to what's the desired location.</li><li tabindex="0" data-start="277480" data-index="41">And we have the blue line that shows the differential part now that immediately decelerates our</li><li tabindex="0" data-start="287670" data-index="42">body but at a smaller overall rate and this will lead to the nice behavior that we've see</li><li tabindex="0" data-start="296670" data-index="43">in the first plot with the red line that moves towards our desired location, but slows</li><li tabindex="0" data-start="303750" data-index="44">down before it actually hits it.</li><li tabindex="0" data-start="306900" data-index="45">And so you might wonder now, what would happen if we set lower gains for this differential part?</li><li tabindex="0" data-start="313900" data-index="46">And then, we get again this behavior that</li><li tabindex="0" data-start="318170" data-index="47">we have seen before, so the red line overshoots now to our desired location, because the slowing</li><li tabindex="0" data-start="325220" data-index="48">down is not strong enough. On the other hand, if we set higher gains for the differential</li><li tabindex="0" data-start="331040" data-index="49">part we end up with the following behavior: it still approaches the desired location</li><li tabindex="0" data-start="340780" data-index="50">nicely, but it takes extremely long like 25 seconds in this example and it could be much faster.</li><li tabindex="0" data-start="347900" data-index="51">So this K_D can also lead to a slower convergence then in the end.</li><li tabindex="0" data-start="355070" data-index="52">Now let's consider the following, before we've just lived in three floating in space, but what</li><li tabindex="0" data-start="363090" data-index="53">would happen if we add gravity to our system?</li><li tabindex="0" data-start="366520" data-index="54">So imagine that next to our controller force F that we generate we add this gravitational</li><li tabindex="0" data-start="374430" data-index="55">constant that accelerates our mass with a certain force.</li><li tabindex="0" data-start="382240" data-index="56">And then, the effect is as follows: we start at 0, again we want to go to 1, but then, the funny thing</li><li tabindex="0" data-start="391470" data-index="57">is the object falls down roughly to 60 meters.</li><li tabindex="0" data-start="399070" data-index="58">And after say 20 seconds or so the PD-control generates sufficiently strong control signals to actually</li><li tabindex="0" data-start="409210" data-index="59">make the object not fall down any further. But this is obviously not what we want, so</li><li tabindex="0" data-start="416080" data-index="60">this would be the case if you just use PD-control without gravity compensation.</li><li tabindex="0" data-start="421140" data-index="61">Then, the quadrotor would never reach its desired location.</li><li tabindex="0" data-start="428590" data-index="62">So what you can do then in such a case is to add an additional term that compensates</li><li tabindex="0" data-start="433310" data-index="63">for the gravity or for any other disturbance that you might be aware of.</li><li tabindex="0" data-start="440710" data-index="64">So directly into our control model we can now include a term for removing this gravitational</li><li tabindex="0" data-start="449070" data-index="65">force to compensate this gravitational force directly.</li><li tabindex="0" data-start="454500" data-index="66">And similar to that, any other known dynamic disturbance can be removed in this way.</li><li tabindex="0" data-start="463680" data-index="67">And then the effect is again as we have seen it before, we can go smoothly form 0 to 1,</li><li tabindex="0" data-start="474250" data-index="68">just by directly compensating force.</li><li tabindex="0" data-start="478990" data-index="69">The next problem now is: imagine that we have some systematic errors in our system. For</li><li tabindex="0" data-start="485310" data-index="70">example, our joystick might not be at the right position, the motors might not be equally</li><li tabindex="0" data-start="491750" data-index="71">strong. It could happen that one motor is a little bit weaker than another one. For</li><li tabindex="0" data-start="495770" data-index="72">example, because it has a broken propeller or just because it doesn't run as smoothly</li><li tabindex="0" data-start="502950" data-index="73">as another motor or it just might be a little bit unbalanced on the quadrotor or there might be some external</li><li tabindex="0" data-start="511080" data-index="74">disturbance like wind that constantly pushes away the quadrotor in a certain direction.</li><li tabindex="0" data-start="518479" data-index="75">And if we add something like this, in this example we have added wind from below that pushes the object upwards.</li><li tabindex="0" data-start="527100" data-index="76">And this is now again similar to what we had before with the gravitation.</li><li tabindex="0" data-start="530900" data-index="77">The object is now approaching this desired location  of 1 but it overshoots and it converges on a</li><li tabindex="0" data-start="542649" data-index="78">value that is not our desired value.  So it converges here on say 1.3 maybe. And on this location the PD-controller generates</li><li tabindex="0" data-start="550560" data-index="79">enough control output to not deviate any further from our desired value but as you can see</li><li tabindex="0" data-start="557089" data-index="80">it does no converge on our desired value. So the questions is: how can we deal with</li><li tabindex="0" data-start="561900" data-index="81">such systematic errors, how can we extend our controller to deal with something like this?</li><li tabindex="0" data-start="567410" data-index="82">And the answer now is to estimate this bias term by integrating over all errors that we</li><li tabindex="0" data-start="578800" data-index="83">had before from the very beginning to the current time step.</li><li tabindex="0" data-start="583399" data-index="84">And this is then called a so called integral term, which you can see here on the right.</li><li tabindex="0" data-start="589470" data-index="85">We again have a coefficient or a gain for the integral term, here denoted by K_I, and this term will</li><li tabindex="0" data-start="598589" data-index="86">build up and then compensate for such errors. So in the example that we have seen before, again</li><li tabindex="0" data-start="605180" data-index="87">we get some overshooting because initially this integral term is 0 so the algorithm doesn't</li><li tabindex="0" data-start="612329" data-index="88">know that we have a disturbance.</li><li tabindex="0" data-start="615519" data-index="89">But as soon as we overshoot and have observed this error this integral builds up and then</li><li tabindex="0" data-start="627500" data-index="90">compensates for it over time and you can see that now our controller</li><li tabindex="0" data-start="631600" data-index="91">nicely converges on the desired value.</li><li tabindex="0" data-start="634129" data-index="92">And in the bottom plot you can now see  how these three terms actually contribute to</li><li tabindex="0" data-start="639069" data-index="93">this behavior. So we have the bright red line corresponding</li><li tabindex="0" data-start="645220" data-index="94">to our proportional control output, the blue line corresponding to our differential output,</li><li tabindex="0" data-start="653999" data-index="95">and the bright green line corresponding to our systematic integral term.</li><li tabindex="0" data-start="664249" data-index="96">So it is in general a bit tricky to use the integral term, its generally fine for</li><li tabindex="0" data-start="671800" data-index="97">steady state systems, so systems that can actually reach their desired location and</li><li tabindex="0" data-start="677670" data-index="98">then it is very reasonable and very good to do that. But it might also happen that you</li><li tabindex="0" data-start="683949" data-index="99">have a system that can never reach a certain location and this might create a</li><li tabindex="0" data-start="690800" data-index="100">so called wind-up effect, which can lead to a disaster or at least to a strong delay in you controller.</li><li tabindex="0" data-start="698350" data-index="101">And now to see why this a problem consider the following example: imagine that we want that</li><li tabindex="0" data-start="704240" data-index="102">the quadrotor goes to a certain location, but then on its way get stuck in a tree, so</li><li tabindex="0" data-start="709279" data-index="103">it cannot reach the steady state. And then it is interesting to look at the</li><li tabindex="0" data-start="713730" data-index="104">effect of this being stuck on the integral term.</li><li tabindex="0" data-start="719490" data-index="105">And then, we see the following behavior: the quadrotor is send to a location of 10 in this</li><li tabindex="0" data-start="726900" data-index="106">example, so it goes quickly towards this location, but roughly at the position of 5 it get stuck</li><li tabindex="0" data-start="736889" data-index="107">in a tree. And from there on this integral term keeps building up, because it realizes that</li><li tabindex="0" data-start="743319" data-index="108">it needs to give more power to the motors apparently to reach its goal location, but it can't because</li><li tabindex="0" data-start="749779" data-index="109">it is stuck. And so this integral term grows larger and larger, as you can see in the bottom plot.</li><li tabindex="0" data-start="754529" data-index="110">And if we send now the quadrotor at the time step 10 back to the origin it won't go, because</li><li tabindex="0" data-start="764600" data-index="111">this integral term still outweighs our proportional-controller that tries to move the quadrotor back.</li><li tabindex="0" data-start="774119" data-index="112">And this is why the integral term is sometimes a bit difficult and dangerous to be used.</li><li tabindex="0" data-start="783550" data-index="113">Another problem of course is that we generally not only have one degree of freedom that we</li><li tabindex="0" data-start="788579" data-index="114">try to control, but typically multiple. In case of the ArDrone we have 4 degrees of freedom</li><li tabindex="0" data-start="795439" data-index="115">as you know, we can go forward, sideward, we can rotate, and we can change the flying height.</li><li tabindex="0" data-start="801660" data-index="116">And this is common with many systems, this is then called a MIMO system - multiple input</li><li tabindex="0" data-start="806490" data-index="117">multiple output. And also it would be of course nice from a</li><li tabindex="0" data-start="811149" data-index="118">theoretical point of view to control all degrees of freedom at the same time with the same controller.</li><li tabindex="0" data-start="815800" data-index="119">Most often these controllers are just being</li><li tabindex="0" data-start="819189" data-index="120">decoupled, so you have 2 or 4 independent PID-controllers, each one just controlling</li><li tabindex="0" data-start="825389" data-index="121">one degree of freedom. And then of course the plant, or the system,</li><li tabindex="0" data-start="830980" data-index="122">that you are looking at couples all of this degrees of freedom, but as long as this coupling</li><li tabindex="0" data-start="839300" data-index="123">is very loose it doesn't hurt to assume for the controllers that these degrees of freedom</li><li tabindex="0" data-start="846779" data-index="124">are actually separate.</li><li tabindex="0" data-start="849639" data-index="125">Another interesting question is then: how to choose then the coefficients? The problem</li><li tabindex="0" data-start="853400" data-index="126">here is that if you make the gains too large, as we have seen it can easily lead to</li><li tabindex="0" data-start="857949" data-index="127">overshooting and oscillations. However, if you make the gains to small, then it might take</li><li tabindex="0" data-start="862679" data-index="128">a very long time to converge. Still a good heuristic is to increase your start with small gains,</li><li tabindex="0" data-start="871740" data-index="129">and then, incrementally increase them until you see a good behavior. If you see oscillations</li><li tabindex="0" data-start="877449" data-index="130">you know that you made them too large and so on.</li><li tabindex="0" data-start="880839" data-index="131">There are some heuristic methods that you can follow that tell you how to tune these</li><li tabindex="0" data-start="885800" data-index="132">parameters, but in practice people often do it just by thump. Try out different values</li><li tabindex="0" data-start="892819" data-index="133">and finding then a parameter setting where you see a reasonable good behavior.</li><li tabindex="0" data-start="899040" data-index="134">Of course, there are more advanced techniques and the whole field of control theory studies</li><li tabindex="0" data-start="904369" data-index="135">these problems, but for our case and especially for the simulator that you'll be using this is completely sufficient.</li><li tabindex="0" data-start="915670" data-index="136">Another thing is of course that we are not only having one controller typically, but</li><li tabindex="0" data-start="919499" data-index="137">a whole sequence of controllers. For example, as you have seen before in hardware we already</li><li tabindex="0" data-start="926149" data-index="138">have motor speed controllers at every motor of the quadrotor, which internally runs not</li><li tabindex="0" data-start="934689" data-index="139">necessarily a PID-controller. Depends on what motor you have, if you can sense the speed,</li><li tabindex="0" data-start="939829" data-index="140">then there is typically something like a P-controller inside. And then, on the next level on the</li><li tabindex="0" data-start="947489" data-index="141">ArDrone for example, this happens onboard is the attitude estimation where you use the</li><li tabindex="0" data-start="951420" data-index="142">gyroscopes and the accelerometers to estimate the orientation of the quadrotor and then</li><li tabindex="0" data-start="956660" data-index="143">generate a suitable attitude control commands. And on top of that you might have a localization</li><li tabindex="0" data-start="963980" data-index="144">module that you're giving the camera images or your GPS signal to compute your position.</li><li tabindex="0" data-start="969639" data-index="145">And then, you might have a PID-controller that controls your position. And even above</li><li tabindex="0" data-start="975420" data-index="146">this layer you might have a trajectory control that generates waypoints</li><li tabindex="0" data-start="982119" data-index="147">to which you want to send the quadrotor. And it's important to note here:</li><li tabindex="0" data-start="985900" data-index="148">just stack different controllers above each other. This is then called cascaded control and this works well</li><li tabindex="0" data-start="996489" data-index="149">as long as the dynamics of the outer system are by at least a magnitude slower than the</li><li tabindex="0" data-start="1008319" data-index="150">dynamics of the internal system. So for the internal controller the set point</li><li tabindex="0" data-start="1014939" data-index="151">then appears to be static. And for the outer controller the dynamics of the internal system</li><li tabindex="0" data-start="1022629" data-index="152">are so fast that it also appears to immediately converge.</li><li tabindex="0" data-start="1028130" data-index="153">So to look at an example now, the ArDrone also uses several control loops. From our perspective</li><li tabindex="0" data-start="1036609" data-index="154">we have an inner loop that runs on the embedded PC, which controls the attitude and the speed</li><li tabindex="0" data-start="1041559" data-index="155">of the quadrotor. And then, the outer loop runs on a Laptop</li><li tabindex="0" data-start="1046559" data-index="156">and implements the position control.</li><li tabindex="0" data-start="1049990" data-index="157">And these two control loops run at different speeds, the internal loop, we don't really</li><li tabindex="0" data-start="1054309" data-index="158">know, but it probably runs at a frequency around 1 kHz. Whie the outer loop runs depending</li><li tabindex="0" data-start="1059409" data-index="159">on you wireless connection runs at approximately 15 to 20 Hz.</li><li tabindex="0" data-start="1066000" data-index="160">And there is another interesting insight, the PD-controller is actually equivalent to a spring-damper system.</li><li tabindex="0" data-start="1074800" data-index="161">So you can imagine that you have your quadrotor that's supposed to go to this desired location</li><li tabindex="0" data-start="1080760" data-index="162">and it's actually being pulled like with virtual springs towards this desired location.</li><li tabindex="0" data-start="1087090" data-index="163">And if you look very closely on this video you can see how this quadrotor moves back</li><li tabindex="0" data-start="1091580" data-index="164">to its set point. And you can see how it is being damped by the D-term of the PD-controller</li><li tabindex="0" data-start="1099690" data-index="165">and how it is being pulled towards its set point using the P-part.</li><li tabindex="0" data-start="1104169" data-index="166">This is actually a very nice demo that we have published as open source and if you have</li><li tabindex="0" data-start="1109390" data-index="167">an ArDrone at home you can just download this demo. You need a Linux computer running ROS</li><li tabindex="0" data-start="1114800" data-index="168">on it, but it is all very well described on this wiki page, so please feel free to try this out.</li><li tabindex="0" data-start="1121620" data-index="169">So to summarize the lesson of this video. We've looked now at full PID-control, remember again:</li><li tabindex="0" data-start="1128000" data-index="170">P stands for the proportional term, I stands for the integral term,</li><li tabindex="0" data-start="1132400" data-index="171">and D stands for the derivative term.</li><li tabindex="0" data-start="1135300" data-index="172">And we have seen how we can stack multiple of such controllers in a cascaded control.</li><li tabindex="0" data-start="1141019" data-index="173">And how we can decouple MIMO systems that have multiple inputs and multiple outputs.</li><li tabindex="-1" style="height: 196px;" class="spacing"></li></ol>
