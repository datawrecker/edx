<ol style="max-height: 451px;" id="transcript-captions" class="subtitles" tabindex="0" role="group" aria-label="Activating an item in this group will spool the video to the corresponding time point. To skip transcript, go to previous item."><li tabindex="-1" style="height: 196px;" class="spacing"></li><li tabindex="0" data-start="1170" data-index="0">Hello and welcome everybody to lecture 4.2 on feedback control. In this video we will</li><li tabindex="0" data-start="6640" data-index="1">look at the problem of how to bring a dynamical system, say a quadrotor for example, in a particular</li><li tabindex="0" data-start="12240" data-index="2">goal state by giving the right sequence of motion or action commands.</li><li tabindex="0" data-start="20080" data-index="3">For example in the case of a quadrotor we often want to move it to a desired goal location. Say</li><li tabindex="0" data-start="25380" data-index="4">above a landing spot or to the landing spot. And for that we need to generate of course</li><li tabindex="0" data-start="31130" data-index="5">a suitable control signal. And this control signal essentially corresponds to the controls</li><li tabindex="0" data-start="37569" data-index="6">that you give with the remote control. So you can change the roll and the pitch or</li><li tabindex="0" data-start="43100" data-index="7">the height, and the yaw angle, the heading.</li><li tabindex="0" data-start="50600" data-index="8">You could not do this blindly, you need to know of course where the robot is at the moment.</li><li tabindex="0" data-start="54850" data-index="9">And then, you can compare this current location that you will have to observe through sensors</li><li tabindex="0" data-start="59030" data-index="10">somehow with your goal location, and then based on the comparison on these two you can generate</li><li tabindex="0" data-start="64989" data-index="11">a suitable control signal.</li><li tabindex="0" data-start="67710" data-index="12">So before we go into more technical details I just want to give you a very intuitive example</li><li tabindex="0" data-start="72890" data-index="13">first on what the generic idea behind feedback control actually is.</li><li tabindex="0" data-start="82320" data-index="14">So imagine for example that you get a morning shower and you get out of the bed and you</li><li tabindex="0" data-start="88820" data-index="15">jump into the shower. And then, you want to switch it on and you want to have your water</li><li tabindex="0" data-start="93119" data-index="16">to have a comfortable temperature, say of 35 degrees. So you are in this case the controller</li><li tabindex="0" data-start="100950" data-index="17">that selects the water temperature and you just switch on the valve or the mixer of your</li><li tabindex="0" data-start="107229" data-index="18">shower and that will make the water flow of the system. The shower is then called the</li><li tabindex="0" data-start="114400" data-index="19">system in control theory or the plant. And then you stand below the shower of course</li><li tabindex="0" data-start="121460" data-index="20">and then you can sense the temperature of the water and then figure out that it's actually</li><li tabindex="0" data-start="127679" data-index="21">not at the 35 degrees that you expected, but much below. And so you feedback, and this is the</li><li tabindex="0" data-start="134900" data-index="22">idea of feedback control, and you feedback this measurement to the controller to take</li><li tabindex="0" data-start="140739" data-index="23">an appropriate action. So in this case you first compare the observed temperature</li><li tabindex="0" data-start="146629" data-index="24">to the desired temperature. You observe that there is a certain discrepancy of a few</li><li tabindex="0" data-start="152120" data-index="25">degrees and so you would turn the valve hotter to hopefully make the water warmer.</li><li tabindex="0" data-start="161560" data-index="26">And if necessary, you do this close looped cycle until the water has reached the right temperature.</li><li tabindex="0" data-start="171349" data-index="27">So much to the generic idea, now let's look at this in a more technical way. It's often</li><li tabindex="0" data-start="178349" data-index="28">drawn in block diagram like this. On the left side you can see the reference signal or the</li><li tabindex="0" data-start="183579" data-index="29">goal state that we try to achieve. And this goal state or desired value is compared to</li><li tabindex="0" data-start="192150" data-index="30">the current state of our system. And then this difference, the so called measurement</li><li tabindex="0" data-start="197019" data-index="31">error, is then feed into a controller. And this controller can be arbitrary complex, but for this video</li><li tabindex="0" data-start="202409" data-index="32">we just look at a proportional, a P controller, as we will see in a second.</li><li tabindex="0" data-start="206849" data-index="33">And this controller then generates a control output. This can be for example a 1 dimensional</li><li tabindex="0" data-start="214930" data-index="34">variable that just specifies whether we should turn it hotter or colder or to move the quadrotor</li><li tabindex="0" data-start="220980" data-index="35">forward or backward. But it can also have multiple dimensions as we will see later.</li><li tabindex="0" data-start="226650" data-index="36">And then this control goes into our system. For example, into the shower or the pipe system.</li><li tabindex="0" data-start="233090" data-index="37">And this control then changes the internal state of the system,</li><li tabindex="0" data-start="238159" data-index="38">so the output of the system is its internal state, which we can then observe with one or more</li><li tabindex="0" data-start="245300" data-index="39">sensors to obtain a measured state.</li><li tabindex="0" data-start="248200" data-index="40">And this measured state is then compared again to the reference value</li><li tabindex="0" data-start="255500" data-index="41">and leads to an updated measured error that is used again by the controller to adjust the controls.</li><li tabindex="0" data-start="263400" data-index="42">So as I said, the controller can be arbitrarily complex but a very simple and efficient controller,</li><li tabindex="0" data-start="271300" data-index="43">thats actually used a lot in practice, is just a linear controller that takes the error</li><li tabindex="0" data-start="276900" data-index="44">that we are getting in and multiplies it by a constant, the so called gain.</li><li tabindex="0" data-start="285000" data-index="45">So this K here can be anything, any positive value in principal. And in this way we take directly the error values.</li><li tabindex="0" data-start="295820" data-index="46">And so the controls depend linearly on the errors.</li><li tabindex="0" data-start="301500" data-index="47">And then, our system can of course also behave arbitrarily complex, but in the case of the shower example,</li><li tabindex="0" data-start="308400" data-index="48">and also for the quadrotor for position control, we can just tread it as a linear system.</li><li tabindex="0" data-start="313800" data-index="49">So the new state can be computed from the old state plus the control that we have given.</li><li tabindex="0" data-start="323820" data-index="50">So if we increase the temperature by 5 degrees, then we would just add +5 to the previous</li><li tabindex="0" data-start="328790" data-index="51">state of the system. And there might be some error constant epsilon here that describes the</li><li tabindex="0" data-start="336600" data-index="52">system noise. Things that are out of our control, for example, a changing temperature or water</li><li tabindex="0" data-start="344100" data-index="53">pressure in the water system.</li><li tabindex="0" data-start="349330" data-index="54">And then this system state gets observed by our sensor. Again the sensor can be arbitrarily</li><li tabindex="0" data-start="356330" data-index="55">complex, but for the shower we could just assume that we have a linear temperature sensor</li><li tabindex="0" data-start="362650" data-index="56">that observes exactly the temperature from the system plus some noise delta that changes</li><li tabindex="0" data-start="369890" data-index="57">every time constant, but it is distributed according to some distribution.</li><li tabindex="0" data-start="376300" data-index="58">So now let's have a look, what this does for our shower example.</li><li tabindex="0" data-start="380720" data-index="59">In the first plot, so now we assume that we have this control law where the control output just</li><li tabindex="0" data-start="387300" data-index="60">depends linearly on our error. And now imagine that we start at say 25 degrees and we want</li><li tabindex="0" data-start="394800" data-index="61">to achieve 35 degrees in the shower to have it comfortably warm. Then in the first time</li><li tabindex="0" data-start="401340" data-index="62">step the algorithm would compare the observed temperature 25 to the desired value 35 and</li><li tabindex="0" data-start="410150" data-index="63">find that there is a difference of +10. So it would feedback a control or it would generate</li><li tabindex="0" data-start="416940" data-index="64">a control of +10. And then within one time step this control</li><li tabindex="0" data-start="422300" data-index="65">would change the temperature of the shower. And in the next time step we already have</li><li tabindex="0" data-start="426130" data-index="66">reached the 35 degrees, and because we are at the desired value already the error term</li><li tabindex="0" data-start="432880" data-index="67">will become 0, and as a result, also the control will become 0 then.</li><li tabindex="0" data-start="440800" data-index="68">Of course this is not very realistic because you always have some noise in such a system.</li><li tabindex="0" data-start="446700" data-index="69">Both, in the process itself so in the system but also in the measurements and in your sensor.</li><li tabindex="0" data-start="454900" data-index="70">And now, for this plot I added some noise in the measurements. So instead of returning</li><li tabindex="0" data-start="461120" data-index="71">exactly the right temperature of the internal state of the system we get a noisy observation</li><li tabindex="0" data-start="466610" data-index="72">of that. But still we can compare this noisy observation with our desired value and with</li><li tabindex="0" data-start="472100" data-index="73">the same law as before we can use that to generate a control. And as you cans see, again</li><li tabindex="0" data-start="481210" data-index="74">we reach roughly the desired temperature but you can also see that it is quite jumpy, for</li><li tabindex="0" data-start="486810" data-index="75">example roughly at 8 seconds time or so, we reach a temperature of 37 or almost 38 degrees.</li><li tabindex="0" data-start="496670" data-index="76">And then, later at maybe 12 seconds time it even drops down to 35. So this is probably</li><li tabindex="0" data-start="504580" data-index="77">not very comfortable in the morning to have such a temperature profile of your shower.</li><li tabindex="0" data-start="512000" data-index="78">Another problem here is that the controller always generates some control commands, so</li><li tabindex="0" data-start="516700" data-index="79">you can see that the green line here in the bottom plot is not reaching 0, it always</li><li tabindex="0" data-start="523789" data-index="80">changes a lot between plus and minus 4 maybe. And this means that if you would be under</li><li tabindex="0" data-start="532300" data-index="81">the shower you would have to constantly adapt the temperature and that's of course not very</li><li tabindex="0" data-start="536899" data-index="82">comfortable, but also for a quadrotor this would not be very energy efficient if you</li><li tabindex="0" data-start="542560" data-index="83">have to give constantly controls just to keep the same temperature.</li><li tabindex="0" data-start="547829" data-index="84">So as you can see, if we keep it as before, if we chose K equals 1, so directly used the error</li><li tabindex="0" data-start="557540" data-index="85">as the control, then we get a relatively poor performance. And now the question of course is:</li><li tabindex="0" data-start="564500" data-index="86">how can we improve on that? And one very simple way is to lower this gain K,</li><li tabindex="0" data-start="573250" data-index="87">to a lower value, say 0.15. If we observe 10 degrees difference between our current</li><li tabindex="0" data-start="583230" data-index="88">value and the desired one, then we will only try to adjust it by 1.5 degrees per time step.</li><li tabindex="0" data-start="592900" data-index="89">And that makes us somewhat more robust against noise, we kind of filter away the noise partially.</li><li tabindex="0" data-start="601220" data-index="90">But it also means that it takes much longer then to reach our desired temperature.</li><li tabindex="0" data-start="605449" data-index="91">So in this example for example the red line, which is the true line of the temperature</li><li tabindex="0" data-start="611370" data-index="92">reaches 35 degrees around 20 seconds time. But nevertheless we can see that it keeps</li><li tabindex="0" data-start="618370" data-index="93">the desired temperature relatively well. Despite this large sensor noise that we have in our system.</li><li tabindex="0" data-start="626900" data-index="94">But the problem obviously is that, if you lower the gain to much, then your system or</li><li tabindex="0" data-start="632900" data-index="95">your controller will get slower and slower and it will take more and more time to reach</li><li tabindex="0" data-start="639100" data-index="96">the desired value.</li><li tabindex="0" data-start="640810" data-index="97">So you could think of how large can you make this gain that it still works.</li><li tabindex="0" data-start="646400" data-index="98">And you might also be tempted to make the gain larger than 1. And this should be noted</li><li tabindex="0" data-start="653110" data-index="99">that this is always problematic actually. For example, consider this example where we</li><li tabindex="0" data-start="656720" data-index="100">chose a coefficient of 2.15. And now what happens is that it always overshoots a lot because</li><li tabindex="0" data-start="666860" data-index="101">it finds that there is a 10 degree difference between the current value and the desired</li><li tabindex="0" data-start="672249" data-index="102">value. So it will multiply that by 2.15, and then, add 20 degrees to that and then be much</li><li tabindex="0" data-start="679249" data-index="103">too high. And then, in the next time step it will find that the temperature is way too high</li><li tabindex="0" data-start="684470" data-index="104">and then reduce it and so on. And this will start to oscillate and actually</li><li tabindex="0" data-start="691230" data-index="105">this oscillations will increase over time.</li><li tabindex="0" data-start="694449" data-index="106">So be careful with to large gains.</li><li tabindex="0" data-start="698740" data-index="107">Another thing that happens often in practice actually, when you program a controller,</li><li tabindex="0" data-start="703930" data-index="108">is that you might end up with the wrong sign either in the coefficient or in the way how you compute the errors.</li><li tabindex="0" data-start="710400" data-index="109">So if you observe when you doing the exercise for this week, and you observe that your quadrotor</li><li tabindex="0" data-start="715300" data-index="110">shoots away in one direction, then maybe check the sign of your error function or of</li><li tabindex="0" data-start="721100" data-index="111">your coefficient.</li><li tabindex="0" data-start="722100" data-index="112">So let's see what's happens if we chose a negative coefficient.</li><li tabindex="0" data-start="726290" data-index="113">And then what we can see, if the algorithm or our controller finds that the temperature</li><li tabindex="0" data-start="730870" data-index="114">is too low it will even make it lower than before. And so the shower reduces the</li><li tabindex="0" data-start="739279" data-index="115">temperature more and more. This is a fun example of course, the temperature</li><li tabindex="0" data-start="743649" data-index="116">drops to negative degrees and then at some point convergence to -272 degrees.</li><li tabindex="0" data-start="753500" data-index="117">So this is the absolute zero point. And this is actually an interesting aspect</li><li tabindex="0" data-start="760900" data-index="118">that in most practical cases you can get saturation effects, either in the state space so that</li><li tabindex="0" data-start="768809" data-index="119">the shower can't get colder than maybe 0 degrees Celsius and that it can't get hotter than</li><li tabindex="0" data-start="777400" data-index="120">maybe 100 degrees. So you don't want to get it hotter than 60 degrees, so you have saturation</li><li tabindex="0" data-start="781790" data-index="121">in the state space. But at the same time you can also have saturation in your control space,</li><li tabindex="0" data-start="788439" data-index="122">which means that you can't arbitrarily fast open the valve for hot water for example</li><li tabindex="0" data-start="794949" data-index="123">or you can't fly or accelerate arbitrarily fast with a quadrotor. And this is then called</li><li tabindex="0" data-start="800550" data-index="124">a control saturation, which just means that your control has a maximum and a minimum value</li><li tabindex="0" data-start="806740" data-index="125">that you can give.</li><li tabindex="0" data-start="808410" data-index="126">So for example, if you have to open the valve by hand, then maybe you can only rotate it</li><li tabindex="0" data-start="814420" data-index="127">at a certain speed. And this might mean that it takes a few seconds until you have opened</li><li tabindex="0" data-start="821980" data-index="128">it enough to get your 35 degrees of desired temperature.</li><li tabindex="0" data-start="829000" data-index="129">Time delays are another very important problem that you have in most practical systems,</li><li tabindex="0" data-start="834800" data-index="130">especially in a shower that you don't know or that you don't know the dynamics. This</li><li tabindex="0" data-start="839559" data-index="131">can be a very tricky problem, so the thing is that you switch on, or you try to increase the temperature,</li><li tabindex="0" data-start="850499" data-index="132">but nothing happens. So for example here in time step 8, the valve is opened or the temperature</li><li tabindex="0" data-start="857309" data-index="133">is being changed. But in the blue line, which gives us the observations from our systems,</li><li tabindex="0" data-start="862399" data-index="134">nothing changes for 5 seconds, because we have a time delay of 5 seconds.</li><li tabindex="0" data-start="869100" data-index="135">And only after these 5 seconds we get the first readings of the changed temperature,</li><li tabindex="0" data-start="874949" data-index="136">but by the time we think that we have reached the 35 degrees, which is roughly at time step</li><li tabindex="0" data-start="880300" data-index="137">19 here, the shower is already much hotter, maybe at 38 or so. Because we don't know we</li><li tabindex="0" data-start="889300" data-index="138">overshoot. And then, we need to reduce the temperature again, give negative controls to bring the</li><li tabindex="0" data-start="899040" data-index="139">temperature down to 35 degrees.</li><li tabindex="0" data-start="902170" data-index="140">And this first effect here is called overshooting, so if you're going beyond the desired value</li><li tabindex="0" data-start="907399" data-index="141">that you are actually trying to achieve. And if it goes back and forth around your desired</li><li tabindex="0" data-start="914800" data-index="142">value, then this is called an oscillation. And in the worst case, depending on how your</li><li tabindex="0" data-start="918379" data-index="143">delays are and what the dynamics are of your system this can even lead to destabilization.</li><li tabindex="0" data-start="924220" data-index="144">One solution always is obviously to lower the gains of your controller, but as we have</li><li tabindex="0" data-start="929709" data-index="145">seen before this is probably a bad idea. It can help, but the disadvantage is that the</li><li tabindex="0" data-start="937499" data-index="146">convergence takes much longer, and maybe you have to wait a few minutes then in the shower until</li><li tabindex="0" data-start="943860" data-index="147">you get the right temperature that you desire.</li><li tabindex="0" data-start="949389" data-index="148">So let's look at this time delay problem in a little bit more detail, because we will</li><li tabindex="0" data-start="953579" data-index="149">also need it for the quadrotors. The problem in general is that you might have several</li><li tabindex="0" data-start="960900" data-index="150">places where time delays can occur. Actually in all of these components you could have</li><li tabindex="0" data-start="965740" data-index="151">time delays, so of course, the most obvious one in the shower example is that the water</li><li tabindex="0" data-start="970050" data-index="152">pipe might introduce a considerable time delay if you have huge pipes with little water going</li><li tabindex="0" data-start="976040" data-index="153">through them. But also your measurement system, your sensor</li><li tabindex="0" data-start="979400" data-index="154">might introduce a certain delay, and also your controller or the communication between these</li><li tabindex="0" data-start="984929" data-index="155">components might introduce delays.</li><li tabindex="0" data-start="988559" data-index="156">So one question here now is: whether or not we can actually distinguish between the individual</li><li tabindex="0" data-start="994329" data-index="157">time delays from within the controller? And the quick answer here is that it's not possible</li><li tabindex="0" data-start="1003179" data-index="158">to distinguish that for the controller. The dead time or the delay of the system or of</li><li tabindex="0" data-start="1009079" data-index="159">the whole loop is not observable, it always appears as if you have a system with 1.2 seconds</li><li tabindex="0" data-start="1018019" data-index="160">delay in this case.</li><li tabindex="0" data-start="1022449" data-index="161">So there is a simple solution to accommodate for delays. And that is the so called Smith</li><li tabindex="0" data-start="1031000" data-index="162">predictor, which allows you to use higher gains then you could use if you just ignore the delays.</li><li tabindex="0" data-start="1040319" data-index="163">However, the Smith predictor requires a very accurate system model and you might not have always</li><li tabindex="0" data-start="1046400" data-index="164">such an accurate model. So the idea of the smith predictor is as follows.</li><li tabindex="0" data-start="1051820" data-index="165">Again, we have a controller that compares the current predicted state with the desired</li><li tabindex="0" data-start="1058820" data-index="166">state, and then generates a control signal that we feed into the system that has a certain</li><li tabindex="0" data-start="1064630" data-index="167">delay. But instead of sensing the output of the system we have a delay free system model</li><li tabindex="0" data-start="1074870" data-index="168">that we calibrated and that we think is accurate as possible to model our real system.</li><li tabindex="0" data-start="1081900" data-index="169">And this model is delay free, so it gives us immediately the expected observation from</li><li tabindex="0" data-start="1089900" data-index="170">the system at the current time step. And we can then feed that back into the controller</li><li tabindex="0" data-start="1094770" data-index="171">to compare it to the desired value.</li><li tabindex="0" data-start="1097450" data-index="172">Now this by itself would only work if you have a perfectly accurate model, which of</li><li tabindex="0" data-start="1102370" data-index="173">course is never the case in any real situation. But this is where the Smith predictor idea</li><li tabindex="0" data-start="1110420" data-index="174">comes in. We still have a sensor then that observes the system state, but remember this</li><li tabindex="0" data-start="1116040" data-index="175">observation set t is actually time delayed by a certain time delay.</li><li tabindex="0" data-start="1121630" data-index="176">And what we now do is we also time delay our prediction z^(pred) that we got from our system</li><li tabindex="0" data-start="1130240" data-index="177">model and we compare these two. And if our model is perfectly accurate, then the difference</li><li tabindex="0" data-start="1136750" data-index="178">between the real sensor observation and the delayed sensor observation should be zero.</li><li tabindex="0" data-start="1142110" data-index="179">If it's however not perfect, then we will get here a residual that we can use to correct</li><li tabindex="0" data-start="1152120" data-index="180">our delay free prediction. And in this way we can take advantage of both,</li><li tabindex="0" data-start="1164100" data-index="181">the delay free system model, but we can also deal with deviations from that. So if our</li><li tabindex="0" data-start="1170400" data-index="182">system model doesn't do anything or is partially wrong then we still have this normal error term</li><li tabindex="0" data-start="1176220" data-index="183">that just considers the difference of the sensor and the model.</li><li tabindex="0" data-start="1183500" data-index="184">So let's first look at a very simple example, where we assume that we have a perfect system</li><li tabindex="0" data-start="1188010" data-index="185">model of our shower, and we have a 5 seconds delay.</li><li tabindex="0" data-start="1192860" data-index="186">The Smith predictor results in a perfect compensation because we know exactly what's going on in</li><li tabindex="0" data-start="1197300" data-index="187">the system. And we can perfectly compensate for the delay then.</li><li tabindex="0" data-start="1204400" data-index="188">Of course, this is completely unrealistic in practice because you never have a good model</li><li tabindex="0" data-start="1208910" data-index="189">or a super accurate model, there will always be some parts of the system that you can't</li><li tabindex="0" data-start="1216300" data-index="190">model exactly. And the other problem is that you typically don't know exactly about the</li><li tabindex="0" data-start="1222180" data-index="191">delay. in some systems you know, but if it's a communication delay for example, that you</li><li tabindex="0" data-start="1226830" data-index="192">get through wireless then this delay or the bandwidth might change as you fly and it's</li><li tabindex="0" data-start="1232680" data-index="193">not always possible to know how long the signal was traveling.</li><li tabindex="0" data-start="1242360" data-index="194">Because you have these uncertainties, the question is: whether you should better over-</li><li tabindex="0" data-start="1248030" data-index="195">or underestimate the time delay?</li><li tabindex="0" data-start="1250900" data-index="196">Let's consider first if we would overestimate the time delay what the result would be.</li><li tabindex="0" data-start="1257900" data-index="197">And then, the effect is as follows: so our system, the Smith predictor predicts too far</li><li tabindex="0" data-start="1264840" data-index="198">into the future, which means that it thinks that just by giving it a certain control command</li><li tabindex="0" data-start="1271760" data-index="199">that we have already reached our desired goal location. Because in a very distant future</li><li tabindex="0" data-start="1277370" data-index="200">we already might be at the desired state or we might even overshoot. So it will greatly</li><li tabindex="0" data-start="1283210" data-index="201">reduce the controls and in the next time step, because it thinks that we're already going</li><li tabindex="0" data-start="1289330" data-index="202">too fast. And then it would project that into the future,</li><li tabindex="0" data-start="1294900" data-index="203">and then realize that it is actually to slow and so it would go back and forth and oscillate.</li><li tabindex="0" data-start="1299880" data-index="204">And as you can see this is clearly not optimal. And it also leads to large changes in the</li><li tabindex="0" data-start="1306400" data-index="205">control. Which is actually not what we want because this costs a lot of energy.</li><li tabindex="0" data-start="1310440" data-index="206">An alternative then is to underestimate the time delay and that is actually what's often</li><li tabindex="0" data-start="1316920" data-index="207">done in practice. Because then you don't get this overshooting effect of you prediction.</li><li tabindex="0" data-start="1323640" data-index="208">Although you still have a certain discrepancy between your model and the actual system, because</li><li tabindex="0" data-start="1328880" data-index="209">you underestimating the time delay. But in this way you can use your model to compensate</li><li tabindex="0" data-start="1333520" data-index="210">for half or maybe 90 percent of your time delay and you consider the rest, as the noise</li><li tabindex="0" data-start="1341850" data-index="211">or the thing that you try to not model and just use directly the sensor readings.</li><li tabindex="0" data-start="1348180" data-index="212">This leads of course to a slightly slower convergence in the end but it circumvents oscillations and</li><li tabindex="0" data-start="1360060" data-index="213">makes your approach the goal state nicely.</li><li tabindex="0" data-start="1366760" data-index="214">So this concludes the video then for this session. We have looked at the control problem, the</li><li tabindex="0" data-start="1372280" data-index="215">feedback control problem in particular. We have introduced proportional control and we</li><li tabindex="0" data-start="1377920" data-index="216">have briefly looked at delay compensation using the Smith predictor.</li><li tabindex="0" data-start="1382560" data-index="217">And then in the next video we will extend this to a full PID control and then apply</li><li tabindex="0" data-start="1388330" data-index="218">that to a position control for quadrotors.</li><li tabindex="-1" style="height: 205.5px;" class="spacing"></li></ol>
