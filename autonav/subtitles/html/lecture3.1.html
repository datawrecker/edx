<ol style="max-height: 451px;" id="transcript-captions" class="subtitles" tabindex="0" role="group" aria-label="Activating an item in this group will spool the video to the corresponding time point. To skip transcript, go to previous item."><li tabindex="-1" style="height: 196px;" class="spacing"></li><li tabindex="0" data-start="1400" data-index="0">Hello and welcome everybody to the course Autonomous Navigation for Flying Robots.</li><li tabindex="0" data-start="5700" data-index="1">In the previous videos we have introduces 2D geometry, and then illustrated how that can be</li><li tabindex="0" data-start="10730" data-index="2">used to compute odometry for a 2 dimensional planar robot. Of course, quadrotors live in</li><li tabindex="0" data-start="18870" data-index="3">a 3 dimensional world, so in this video we will now extend that to full 3D. Similar as before</li><li tabindex="0" data-start="25900" data-index="4">we can now define points in 3D. A 3D point of course consists of 3 dimensions for the x, y and z axis.</li><li tabindex="0" data-start="36500" data-index="5">And agian, we can augment such a vector by a 1 in an additional row at the end, which is then called</li><li tabindex="0" data-start="43970" data-index="6">an augmented vector again. We can define homogeneous coordinates or a homogeneous</li><li tabindex="0" data-start="50430" data-index="7">vector that has four elements. And remember, two homogeneous vectors are representing the</li><li tabindex="0" data-start="57800" data-index="8">same point in 3D if and only if they only differ by scale. Using such points we can</li><li tabindex="0" data-start="66610" data-index="9">now a line in 3D. There are different ways of representing lines.</li><li tabindex="0" data-start="71200" data-index="10">A very simple form is to just use 2 points. And the line connecting these two points can</li><li tabindex="0" data-start="79400" data-index="11">then be defined as a linear blending between the coordinates of these two points. So in this formula if Lambda</li><li tabindex="0" data-start="89040" data-index="12">is 0 then we are exactly at point p, and if Lambda is 1 then we are exactly at point q.</li><li tabindex="0" data-start="96500" data-index="13">For any values between 0 and 1, we would interpolate between p and q along line</li><li tabindex="0" data-start="102600" data-index="14">segment joining these two points. And if Lambda can take any real value, then we are moving</li><li tabindex="0" data-start="108900" data-index="15">along the infinite line defined by these two points.</li><li tabindex="0" data-start="113860" data-index="16">We can also define a 3D plane, a 3D plane can be described by 3 parameters, in principal.</li><li tabindex="0" data-start="124200" data-index="17">But it is easier to use the homogeneous representation. So this vector m here, m tilde has 4 coefficients,</li><li tabindex="0" data-start="134889" data-index="18">and if you multiply that with a 3D point, x bar or x tilde, and set it to 0 then this</li><li tabindex="0" data-start="142319" data-index="19">formula defines all points lying on the plane.</li><li tabindex="0" data-start="146969" data-index="20">And again, from this equation you can see that the scale actually doesn't matter. So</li><li tabindex="0" data-start="153059" data-index="21">if you multiply it by a constant then you still getting the same points on the line.</li><li tabindex="0" data-start="159919" data-index="22">Similar as before, we can now normalize this plane equation by saying that the first 3</li><li tabindex="0" data-start="165879" data-index="23">components x and y and z have a length of 1. Then this vector actually corresponds</li><li tabindex="0" data-start="175609" data-index="24">to the normal vector. And if it has length 1 it's a unit normal vector. And then the</li><li tabindex="0" data-start="181299" data-index="25">last coefficient d specifies the distance of the plane from the origin.</li><li tabindex="0" data-start="189100" data-index="26">Then we can also define 3D transformations again. A translation as before can be specified</li><li tabindex="0" data-start="197359" data-index="27">by a multiplication of a 4 by 4 matrix with a vector. For only a translation we would</li><li tabindex="0" data-start="204930" data-index="28">have the identity in the upper left and then the 3 dimensional translation vector in the</li><li tabindex="0" data-start="209760" data-index="29">upper right. And then, if we replace this identity in the</li><li tabindex="0" data-start="216900" data-index="30">upper left by a 3 dimensional rotation matrix, then we obtain an euclidian transform.</li><li tabindex="0" data-start="223000" data-index="31">Elements of this type are also called to be elements of the special euclidian group of dimension 3.</li><li tabindex="0" data-start="231500" data-index="32">Just saying that we are dealing here with rotation and translation at the same time.</li><li tabindex="0" data-start="238559" data-index="33">And as before you can define a scaled rotation, where we have an additional scaling factor</li><li tabindex="0" data-start="243829" data-index="34">to grow or shrink objects or trajectories in 3D. You can define an affine transform</li><li tabindex="0" data-start="254400" data-index="35">to stretch an object. You can define projective transformations</li><li tabindex="0" data-start="261000" data-index="36">and homographies that are even more general. But for the moment, and mostly for this course we need euclidian</li><li tabindex="0" data-start="267819" data-index="37">transformations to move around the robot in 3D and to compute motions between poses.</li><li tabindex="0" data-start="277620" data-index="38">So now let's look a little bit more at 3D euclidian transformations. Obviously the translation</li><li tabindex="0" data-start="284120" data-index="39">which is a 3 dimensional vector has 3 degrees of freedom because we can move around the</li><li tabindex="0" data-start="288470" data-index="40">object or the quadrotor along all 3 axes. And similarly also the rotation has a 3 degrees</li><li tabindex="0" data-start="295840" data-index="41">of freedom because we can turn the quadrotor around all 3 principle axes.</li><li tabindex="0" data-start="302520" data-index="42">Now if you look closer at this rotation matrix then you see that it actually consists of</li><li tabindex="0" data-start="307419" data-index="43">9 elements because it's a 3 by 3 orthogonal matrix. And this group is also called a special</li><li tabindex="0" data-start="318800" data-index="44">orientation group SO(3) because it preserves scale and the angles.</li><li tabindex="0" data-start="328360" data-index="45">And to read such a rotation matrix you can look at the column vectors and then these</li><li tabindex="0" data-start="333800" data-index="46">vectors correspond to the coordinate axes after the transformation.</li><li tabindex="0" data-start="340680" data-index="47">So what do we now typically need to do with this rotation matrices? Or what are the operations</li><li tabindex="0" data-start="346080" data-index="48">that we frequently have to apply? But of course one thing, and we have seen</li><li tabindex="0" data-start="349539" data-index="49">that already before, we need to invert them and need to be able to concatenate them. For</li><li tabindex="0" data-start="355000" data-index="50">example, to integrate the odometry from sensors and of course we need to the inverse.</li><li tabindex="0" data-start="362200" data-index="51">Sometimes we need to estimate a rotation matrix because we want to find out how the robot moved between</li><li tabindex="0" data-start="371430" data-index="52">two time steps. And now the question is, how easy are these operations on matrices? So</li><li tabindex="0" data-start="378270" data-index="53">is a rotation matrix actually the right representation to solve these tasks?</li><li tabindex="0" data-start="385600" data-index="54">And obviously 3D rotation matrices can very easily concatenated, just by multiplying them.</li><li tabindex="0" data-start="393300" data-index="55">And they can also be very easily be inverted.</li><li tabindex="0" data-start="397219" data-index="56">So those of you who have listened carefully will remember that the rotation matrix or</li><li tabindex="0" data-start="402909" data-index="57">an orthogonal matrix can be inverted just by taking the transpose of the matrix. And</li><li tabindex="0" data-start="410000" data-index="58">that's of course a super-fast operation.</li><li tabindex="0" data-start="415169" data-index="59">The disadvantage is, and that's especially a disadvantage if you need to find the rotation</li><li tabindex="0" data-start="418990" data-index="60">between two points in space, is that it's completely over-parameterized.</li><li tabindex="0" data-start="424659" data-index="61">You have 9 coefficients instead of only the 3 real degrees of freedom.</li><li tabindex="0" data-start="431210" data-index="62">So if you use that in an optimization task then you will have to make sure that the nine</li><li tabindex="0" data-start="437050" data-index="63">parameters your are estimating actually form a valid rotation matrix and that's actually</li><li tabindex="0" data-start="441990" data-index="64">not very trivial.</li><li tabindex="0" data-start="445219" data-index="65">So the question is: aren't there any other representations that are minimal or close</li><li tabindex="0" data-start="450620" data-index="66">to minimal and that help us during this optimization problems?</li><li tabindex="0" data-start="458700" data-index="67">One very common form and probably also the best known form of such a representation are</li><li tabindex="0" data-start="465069" data-index="68">the euler angles.</li><li tabindex="0" data-start="466150" data-index="69">The euler angles are just a product of 3 consecutive rotations</li><li tabindex="0" data-start="476240" data-index="70">around a predefined order of axes. For example, it would first rotate around the x axis, then</li><li tabindex="0" data-start="484199" data-index="71">around the y axis, and then rotate around the z axis.</li><li tabindex="0" data-start="487599" data-index="72">Especially in aerial navigation the so called</li><li tabindex="0" data-start="490340" data-index="73">roll-pitch-yaw convention is very common.</li><li tabindex="0" data-start="493729" data-index="74">And this means that you specify first the roll angle along the main axis of the quadrotor</li><li tabindex="0" data-start="500900" data-index="75">or the plane. Then the pitch angle, which specifies the rotation around the wings of the robot (plane).</li><li tabindex="0" data-start="512510" data-index="76">And then the yaw angle, which describes the heading of the quadrotor or the plane.</li><li tabindex="0" data-start="522000" data-index="77">Then you typically want to convert from euler angles to rotation matrices and vice versa.</li><li tabindex="0" data-start="531500" data-index="78">And you can do that as follows: so you can specify</li><li tabindex="0" data-start="536070" data-index="79">the euler angles as 3 values, the roll, pitch and yaw angle. Then we use that to compute</li><li tabindex="0" data-start="545070" data-index="80">3 individual rotation matrices. A rotation around the z axis, a rotation around the y</li><li tabindex="0" data-start="549230" data-index="81">axis, and a rotation around the x axis, and then you concatenate all 3 of them.</li><li tabindex="0" data-start="554630" data-index="82">So every individual rotation matrix is very simple, because it's just a sine and cosine</li><li tabindex="0" data-start="561240" data-index="83">to describe the rotation around a certain axes. But if you multiply all of them together</li><li tabindex="0" data-start="566459" data-index="84">then you get a very ugly expression as shown her at the bottom.</li><li tabindex="0" data-start="572930" data-index="85">And then again, if you want go back from a rotation matrix to roll-pitch-yaw angles, then you</li><li tabindex="0" data-start="580160" data-index="86">could use these formulas. There are other formulas as well that bring you there. Because</li><li tabindex="0" data-start="585760" data-index="87">it's over parameterized it's hard to find the best way in the presents of noise for doing that.</li><li tabindex="0" data-start="597870" data-index="88">So the advantage of euler angles clearly is that it's a minimal representation. You only</li><li tabindex="0" data-start="602600" data-index="89">have 3 parameters and they have a very easy representation, especially when your angles</li><li tabindex="0" data-start="608740" data-index="90">are close to 0, because then you can just imagine in your head how the plane would be rotated</li><li tabindex="0" data-start="615050" data-index="91">or how far it is away from the resting position. The disadvantage is that there are many different</li><li tabindex="0" data-start="624070" data-index="92">euler representations and there is typically confusion when somebody sends you euler angles,</li><li tabindex="0" data-start="629240" data-index="93">because you never know whether they use the XYZ convention or is the other way around</li><li tabindex="0" data-start="634540" data-index="94">ZYX and so on.</li><li tabindex="0" data-start="636449" data-index="95">So I think there are 24 different ways of interpreting euler angles and that makes it</li><li tabindex="0" data-start="643600" data-index="96">sometimes hard to communicate with them in the right way.</li><li tabindex="0" data-start="647060" data-index="97">The other problem is that it's really difficult to concatenate them because you have always</li><li tabindex="0" data-start="651050" data-index="98">to convert them to a rotation matrix and then do the concatenation there and then extract</li><li tabindex="0" data-start="656740" data-index="99">again the resulting euler angles.</li><li tabindex="0" data-start="660220" data-index="100">And the last problem, and that's actually in terms of optimization the hardest one that</li><li tabindex="0" data-start="666300" data-index="101">euler angles have singularities: they can get locked in a so called gimbal lock problem,</li><li tabindex="0" data-start="673500" data-index="102">as illustrated here. It can happen in the euler angles that two</li><li tabindex="0" data-start="679910" data-index="103">axes are being aligned and in this situation you losing 1 degree of freedom.</li><li tabindex="0" data-start="686850" data-index="104">For example, these 3 rings here, so each of these rings now describes one rotation</li><li tabindex="0" data-start="694060" data-index="105">accordingly to the roll-pitch-yaw formulation. But it can happen that all of these axes then</li><li tabindex="0" data-start="703400" data-index="106">align, and then we have all of this three disks lying in one plane. And then in this plane</li><li tabindex="0" data-start="710500" data-index="107">you can't rotate anymore around the central axis, the yaw angle.</li><li tabindex="0" data-start="718900" data-index="108">This can be very bad and can't be solved with euler angles.</li><li tabindex="0" data-start="726500" data-index="109">An alternative representation and also quite intuitive one is the so called axis/angle</li><li tabindex="0" data-start="732069" data-index="110">representation. There the idea is that you describe a rotation by a rotation axis. A</li><li tabindex="0" data-start="739600" data-index="111">normal direction vector in 3D and a rotation angle Theta that says by how far you rotate</li><li tabindex="0" data-start="745880" data-index="112">around this axis.</li><li tabindex="0" data-start="748170" data-index="113">This representation than has 4 degrees of freedom because you need 3 degrees of freedom</li><li tabindex="0" data-start="753850" data-index="114">to specify this direction and a fourth parameter to specify the rotation angle.</li><li tabindex="0" data-start="761399" data-index="115">You can combine both of that together by saying that the length of you axis directly encodes</li><li tabindex="0" data-start="770589" data-index="116">the rotation angle. So a rotation of 0 would just be the 0-vector. A rotation of 180 degrees</li><li tabindex="0" data-start="782630" data-index="117">would mean that your rotation vector has a length of Pi.</li><li tabindex="0" data-start="793000" data-index="118">This representation, where you have just 3 parameters, is also called the angular velocity</li><li tabindex="0" data-start="797759" data-index="119">representation or a so called twist. This is again a minimal representation, but</li><li tabindex="0" data-start="805810" data-index="120">it is not unique similarly to the euler angles. I guess you can imagine why this is the case.</li><li tabindex="0" data-start="812600" data-index="121">So every 2 Pi you repeat the same rotation, because if you rotate more than 360 degrees</li><li tabindex="0" data-start="820949" data-index="122">then you are again at the same spot.</li><li tabindex="0" data-start="827639" data-index="123">There are again formulas to convert from axis angle to rotation matrices and back.</li><li tabindex="0" data-start="836400" data-index="124">From axis/angle to rotation matrices the conversion formula is called the Rodriguez formula, as</li><li tabindex="0" data-start="843500" data-index="125">given here. The inverse is also given here.</li><li tabindex="0" data-start="849579" data-index="126">For more information there is lots of more things to be said here, but to keep it simple,</li><li tabindex="0" data-start="855360" data-index="127">and because we don't really need it in the rest of the course I would like to refer you</li><li tabindex="0" data-start="859589" data-index="128">to the book of Ma and colleagues and in particular to chapter 2. If you google for this then</li><li tabindex="0" data-start="868529" data-index="129">you can find an online copy.</li><li tabindex="0" data-start="872800" data-index="130">So as I said the axis/angle representation is also called twist coordinates. The advantages</li><li tabindex="0" data-start="879100" data-index="131">are: it's a minimal representation, and a second advantage is that the derivations are</li><li tabindex="0" data-start="885639" data-index="132">really simple of that. So especially for optimization problems that</li><li tabindex="0" data-start="889759" data-index="133">we will see later the axis/angle representation is really beneficial.</li><li tabindex="0" data-start="894870" data-index="134">The disadvantage again, similar to euler angles again is that it's difficult to concatenate them.</li><li tabindex="0" data-start="900000" data-index="135">You always need to go to a rotation matrix, and then multiply them there and convert</li><li tabindex="0" data-start="905900" data-index="136">them back to axis/angle. And the conversion is also fairly slow because</li><li tabindex="0" data-start="910470" data-index="137">you need to compute sine and cosine, which can be at least on some processors costly operations.</li><li tabindex="0" data-start="919790" data-index="138">So a last representations for 3D rotations is so called quaternions.</li><li tabindex="0" data-start="924589" data-index="139">A quaternion is a 4 dimensional vector representing a rotation. It can be split into a real and</li><li tabindex="0" data-start="933649" data-index="140">a vector part. The real part is just a number and the vector part is a 3 dimensional vector then.</li><li tabindex="0" data-start="940569" data-index="141">And you can normalize them such that the length</li><li tabindex="0" data-start="945879" data-index="142">of the quaternion is exactly 1. And in this case you can imagine these unit</li><li tabindex="0" data-start="951149" data-index="143">quaternions to be points on a 4 dimensional sphere of radius 1.</li><li tabindex="0" data-start="959800" data-index="144">And then there is one ambiguity in quaternions: opposite sign quaternions represent the same</li><li tabindex="0" data-start="968000" data-index="145">rotation. So the unit quaternion actually just lives</li><li tabindex="0" data-start="971279" data-index="146">on one half of a sphere, and the other half of the sphere then represents the same rotations.</li><li tabindex="0" data-start="978279" data-index="147">But otherwise quaternions are unique.</li><li tabindex="0" data-start="981970" data-index="148">So the really good news on quaternions is that they are easy to multiply, to concatenate</li><li tabindex="0" data-start="987310" data-index="149">and they can be easily inverted. So they are really efficient and easy to implement. And</li><li tabindex="0" data-start="992850" data-index="150">this is the reason why many quadrotors that need to do these operations onboard actually</li><li tabindex="0" data-start="1001000" data-index="151">use the quaternion representation. For example to concatenate two quaternions</li><li tabindex="0" data-start="1007079" data-index="152">it's just a small number of multiplications, and subtractions and additions that you need</li><li tabindex="0" data-start="1011900" data-index="153">to do. So things that you can do fairly easy on an embedded system. Also to compute the</li><li tabindex="0" data-start="1017800" data-index="154">inverse is extremely easy you just flip the sign of either the real or imaginary part.</li><li tabindex="0" data-start="1023300" data-index="155">So two more things that you would like to do with quaternions is to rotate a 3D vector</li><li tabindex="0" data-start="1027940" data-index="156">using the rotation represented by the quaternion, and this turns out to be just again a multiplication</li><li tabindex="0" data-start="1034550" data-index="157">of the quaternion with the vector and the conjugate of the quaternion, which is extremely</li><li tabindex="0" data-start="1041119" data-index="158">fast to compute. And if you want to, you can convert of course quaternions to the other</li><li tabindex="0" data-start="1048500" data-index="159">types. For example, it's closely related to the axis/angle</li><li tabindex="0" data-start="1052600" data-index="160">representation. But of course, you can also transform a quaternion to a rotation matrix and convert</li><li tabindex="0" data-start="1057620" data-index="161">the rotation matrix to a quaternion.</li><li tabindex="0" data-start="1062750" data-index="162">So to summarize that, there are different representations of 3D rotations.</li><li tabindex="0" data-start="1070500" data-index="163">There is not really a single best one it depends on your application.</li><li tabindex="0" data-start="1074400" data-index="164">If you jusst need to just concatenate things then rotation matrices and quaternions are very well suited.</li><li tabindex="0" data-start="1081270" data-index="165">If you want to optimize a 3D representation,</li><li tabindex="0" data-start="1085290" data-index="166">then the axis/angle representation is very well suited.</li><li tabindex="0" data-start="1089300" data-index="167">And maybe one thing in general that is good to know, even for experts in 3D orations or</li><li tabindex="0" data-start="1098300" data-index="168">3D geometry it's really hard to parse or read a 3D rotation vector, no matter in what representation.</li><li tabindex="0" data-start="1107180" data-index="169">So if I see euler angles I typically do not know what rotation they do correspond with,</li><li tabindex="0" data-start="1113490" data-index="170">except if it's maybe close to the origin. And the same holds for a rotation matrix,</li><li tabindex="0" data-start="1118310" data-index="171">I think there are very few people only who can tell you how an object is oriented if</li><li tabindex="0" data-start="1122670" data-index="172">the see the rotation matrix. And it gets even harder for the axis/angle</li><li tabindex="0" data-start="1129700" data-index="173">and in particular for the quaternion representation. So if you look at something like this and</li><li tabindex="0" data-start="1136500" data-index="174">don't know what rotation it is, be assured this is normal and there is no good way of</li><li tabindex="0" data-start="1141590" data-index="175">interpreting it manually. But one thing that can help you here because</li><li tabindex="0" data-start="1146580" data-index="176">you need to debug of course your program at some point is to use good 3D visualization tools.</li><li tabindex="0" data-start="1155100" data-index="177">For example, under Linux when you use ROS (the Robot Operating System), there is a good</li><li tabindex="0" data-start="1160330" data-index="178">tool called Rviz. Under C++ there is the library QGLViewer. And of course for our online exercises</li><li tabindex="0" data-start="1168500" data-index="179">we have this WebGL based 3D viewer that will help you to determine whether your orientations</li><li tabindex="0" data-start="1174310" data-index="180">and rotations are right.</li><li tabindex="0" data-start="1177920" data-index="181">Now the last part in this video is now that we need to be able to do 3D to 2D perspective</li><li tabindex="0" data-start="1184180" data-index="182">projections, as they happen in 2D or in cameras. So for example, here we have two objects being</li><li tabindex="0" data-start="1195440" data-index="183">located in the real world in 3D. And we have a camera actually observing these objects.</li><li tabindex="0" data-start="1202170" data-index="184">And then these objects being projected on the image plane of the camera. So we need</li><li tabindex="0" data-start="1208630" data-index="185">to find a way to compute from the 3D points in the world the 2D coordinates on the image</li><li tabindex="0" data-start="1217300" data-index="186">plane. And the most used model for cameras that holds</li><li tabindex="0" data-start="1222780" data-index="187">for most cameras which have normal lenses is the so called pin-hole camera model, where</li><li tabindex="0" data-start="1229570" data-index="188">you just remove essentially the last component of your homogeneous vector to obtain a 2 dimensional</li><li tabindex="0" data-start="1239340" data-index="189">homogeneous vector of your point. And then again, x tilde is homogeneous so</li><li tabindex="0" data-start="1246500" data-index="190">we need to divide by the last coordinate to obtain the real coordinate on the image plane.</li><li tabindex="0" data-start="1256000" data-index="191">One problem of course is so far if we just down project a 3D point in the world to 2D,</li><li tabindex="0" data-start="1262690" data-index="192">the 2D point will still be given in the same units as our 3D point.</li><li tabindex="0" data-start="1268000" data-index="193">For example, if our 3D points are specified in meters, then also the 2D point will be specified</li><li tabindex="0" data-start="1273250" data-index="194">in meters on the image plane, but of course, what we need with digital cameras is the pixel</li><li tabindex="0" data-start="1279750" data-index="195">position. So we need to convert this position in meters to a position in pixels. And for</li><li tabindex="0" data-start="1290300" data-index="196">that we need to apply some scaling and offset. This matrix that does this scaling and offset</li><li tabindex="0" data-start="1299130" data-index="197">is usually called the intrinsic matrix. It is sometimes abbreviated with a K and it consist</li><li tabindex="0" data-start="1305270" data-index="198">of 5 parameters. Namely the focal length f_x and f_y that specifies in principle the opening</li><li tabindex="0" data-start="1315520" data-index="199">angle of your camera. The larger this focal length is the smaller the opening angle of your</li><li tabindex="0" data-start="1320800" data-index="200">camera is and vice versa. A normal camera for example, like a webcam</li><li tabindex="0" data-start="1327680" data-index="201">with say 60 degrees of opening angle has a focal length of around 500 to 1000.</li><li tabindex="0" data-start="1338630" data-index="202">Then we also need to specify where the camera center is. This is typically in the middle</li><li tabindex="0" data-start="1344210" data-index="203">of the image, but it doesn't necessarily have to be there. It depends on how exactly where</li><li tabindex="0" data-start="1349180" data-index="204">the lens is mounted and where exactly the sensor is mounted. So during calibration it makes often</li><li tabindex="0" data-start="1354970" data-index="205">sense to calculate these values. And then there can be a skew factor that determines</li><li tabindex="0" data-start="1362470" data-index="206">whether or not the pixels on the image array are actually orthogonal or not.</li><li tabindex="0" data-start="1369400" data-index="207">But actually on all modern cameras there is no skew, so this s can be assumed to be 0.</li><li tabindex="0" data-start="1375880" data-index="208">And then one last thing, of course the 3D point coordinates that we've been looking</li><li tabindex="0" data-start="1380900" data-index="209">at previously are typically given in world coordinates.</li><li tabindex="0" data-start="1386870" data-index="210">So before we can project them onto the image plane we need to transform them from world</li><li tabindex="0" data-start="1391850" data-index="211">coordinates to the local camera system. This transformations is also called the camera</li><li tabindex="0" data-start="1398760" data-index="212">extrinsic parameters. In these parameters is described where the camera is located in</li><li tabindex="0" data-start="1406100" data-index="213">3D space. And this is similar as we have seen before,</li><li tabindex="0" data-start="1410770" data-index="214">the conversion from a global coordinate system to the local coordinate system of the camera.</li><li tabindex="0" data-start="1418240" data-index="215">And now we can concatenate all these transformations so we have a 3D world p_w being transformed</li><li tabindex="0" data-start="1428520" data-index="216">into the local coordinate frame of the camera. And then being projected to 2D, and</li><li tabindex="0" data-start="1434880" data-index="217">scaled and offsetted according to the camera intrinsic.</li><li tabindex="0" data-start="1438110" data-index="218">And then, these homogeneous vector x here gives us the coordinates on the screen or on the</li><li tabindex="0" data-start="1445800" data-index="219">image plane.</li><li tabindex="0" data-start="1449000" data-index="220">So to summarize the video of today:</li><li tabindex="0" data-start="1453210" data-index="221">we have looked at 3D points, lines and planes, we have also introduced 3D transformations,</li><li tabindex="0" data-start="1458500" data-index="222">in particular the euclidian transformation that we will be using a lot in this course.</li><li tabindex="0" data-start="1463920" data-index="223">And then, we have look at different representations for 3D orientations. And as we have summarized</li><li tabindex="0" data-start="1471820" data-index="224">earlier, the choice greatly depends on the application you're looking at and in the next</li><li tabindex="0" data-start="1477300" data-index="225">quiz we will ask you again to summarize which of these representations you still remember</li><li tabindex="0" data-start="1484700" data-index="226">and what the advantages and disadvantages are.</li><li tabindex="0" data-start="1487510" data-index="227">And we looked at 3D to 2D perspective projections as it happens in a normal camera.</li><li tabindex="0" data-start="1495300" data-index="228">So these things here that we have looked at today are really important and you really</li><li tabindex="0" data-start="1501630" data-index="229">have to know them by heart.</li><li tabindex="0" data-start="1504610" data-index="230">If you had the feeling by watching this video that you didn't fully understand it, then</li><li tabindex="0" data-start="1509230" data-index="231">my advice would be to look at the computer vision book of Richard Szeliski, in particular</li><li tabindex="0" data-start="1516200" data-index="232">chapter 2. It's fully available online (http://szeliski.org/Book/)</li><li tabindex="0" data-start="1519510" data-index="233">with lots of material. Please have a look at that.</li><li tabindex="-1" style="height: 205.5px;" class="spacing"></li></ol>
